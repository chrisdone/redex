// Implements a trivial l-calc interpreter. Needs a renamer to be fully correct.
//
// Duet has cases and type classes (not necessary for such a
// demonstration) and top-level bindings (needed for recursion) and a
// renamer, which are necessary for a complete demonstration.
//
// To test this properly, I could quickly generate values of
// Expression and compile some Rust off the cuff to see whether the
// output make sense. Later, I could use the FFI with
// e.g. (https://github.com/mgattozzi/curryrs) or the modern
// equivalent.

#[derive(Debug, PartialEq, Clone)]
// These boxes could be references, and the stepper could be a mutator.
enum Expression<'a> {
    VariableExpression { name: &'a str },
    // In Haskell Duet, this is a unique int generated by the renamer.
    // In practice, the renamer is called before each stepper call.
    LiteralExpression { literal: Literal },
    ApplicationExpression { function: Box<Expression<'a>>, argument: Box<Expression<'a>> },
    LambdaExpression { parameter: &'a str, body: Box<Expression<'a>> }
}

#[derive(Debug, PartialEq, Clone)]
enum Literal {
    IntegerLiteral { i64: i64 }
}

fn main() {
    step(Expression::VariableExpression {name: "x"});
    step(Expression::LiteralExpression {literal: Literal::IntegerLiteral {i64: 123}});
    step(Expression::ApplicationExpression {
        function: Box::new(Expression::LambdaExpression {
            parameter: "x",
            body: Box::new(Expression::VariableExpression {name: "x"})
        }),
        argument: Box::new(Expression::LiteralExpression {
            literal: Literal::IntegerLiteral {i64: 123}
        })
    });
    step(Expression::ApplicationExpression {
        function: Box::new(Expression::ApplicationExpression {
            function: Box::new(Expression::LambdaExpression {
                parameter: "x",
                body: Box::new(Expression::LambdaExpression {
                    parameter: "y",
                    body: Box::new(Expression::ApplicationExpression {
                        function: Box::new(Expression::VariableExpression {name: "x"}),
                        argument: Box::new(Expression::VariableExpression {name: "y"})})})}),
            argument: Box::new(Expression::LambdaExpression {
                parameter: "z",
                body: Box::new(Expression::VariableExpression {name: "z"})
            }) }),
    argument: Box::new(Expression::LiteralExpression {literal: Literal::IntegerLiteral {i64: 123}})})
}

// Just call expand_whnf and repeat. Didn't even bother to use a loop.
fn step(e: Expression) {
    let e_clone = e.clone();
    println!("= {:#?}", e);
    let e_expanded = expand_whnf(e);
    if e_clone == e_expanded {
        println!("Done!")
    } else {
        step(e_expanded);
        // This could instead be a loop providing a coroutine ("iterator").
    }
}

// Haskell equiv. https://github.com/duet-lang/duet/blob/f58e0f537c55713048fa17c723c7d0ad80a31368/src/Duet/Stepper.hs#L75
fn expand_whnf(e: Expression) -> Expression {
    match e {
        // No-ops:
        Expression::VariableExpression{..} => e,
        Expression::LiteralExpression{..} => e,
        Expression::LambdaExpression{..} => e,
        // Application of lambdas
        Expression::ApplicationExpression{function, argument} =>
            match *function {
                Expression::LambdaExpression{parameter, body} =>
                    substitute(parameter, *body, *argument),
                func => {
                    let inner = expand_whnf(func);
                    Expression::ApplicationExpression{function: Box::new(inner), argument}
                }
            }
    }
}

// Haskell equiv. https://github.com/duet-lang/duet/blob/f58e0f537c55713048fa17c723c7d0ad80a31368/src/Duet/Stepper.hs#L313
fn substitute<'a>(that: &'a str, e: Expression<'a>, arg: Expression<'a>) -> Expression<'a> {
    match e {
        Expression::VariableExpression { name } =>
            if name == that {
                arg
            } else {
                e
            },
        Expression::LiteralExpression{..} => e,
        Expression::LambdaExpression{parameter, body} =>
            // This isn't necessary with a renamer step, which serves
            // as an early alpha conversion.
            if parameter == that {
                Expression::LambdaExpression{parameter, body}
            } else {
                Expression::LambdaExpression {
                    parameter,
                    body: Box::new(substitute(that, *body, arg))
                }
            },
        Expression::ApplicationExpression{function, argument} =>
            Expression::ApplicationExpression{
                function: Box::new(substitute(that, *function, arg.clone())),
                argument: Box::new(substitute(that, *argument, arg.clone()))
            }
    }
}

// Missing

// https://github.com/duet-lang/duet/blob/f58e0f537c55713048fa17c723c7d0ad80a31368/src/Duet/Stepper.hs#L248
